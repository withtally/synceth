package codegen

import (
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestGenerateProcessor comprehensively tests the GenerateProcessor function with various scenarios.
// This consolidated test covers:
// - Basic event processor generation
// - Multiple events in a single contract
// - Multiple contracts with events
// - Events with array types
// - Events with indexed parameters
// - Empty events (no inputs)
// - Complex event signatures
// - Custom input types for processors
// - Setup input types
// - Anonymous events (should be skipped)
// - Invalid ABI JSON
// - No events in contract
// - Package name variations
func TestGenerateProcessor(t *testing.T) {
	tests := []struct {
		name           string
		types          []string
		abis           []string
		pkg            string
		inputs         []InputType
		setupInputs    []InputType
		expectedOutput string
		wantErr        bool
		errContains    string
	}{
		{
			name:  "basic_single_event",
			types: []string{"SimpleContract"},
			abis: []string{`[{
				"name": "DataChanged",
				"type": "event",
				"inputs": [{"name": "value", "type": "uint256"}]
			}]`},
			pkg: "testpkg",
			expectedOutput: `// Code generated by github.com/withtally/synceth, DO NOT EDIT.

package testpkg

import (
	"context"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

type SimpleContractProcessor interface {
	Setup(ctx context.Context, address common.Address, eth interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}) error
	Initialize(ctx context.Context, start uint64) error

	ProcessDataChanged(ctx context.Context, e SimpleContractDataChanged) (func() error, error)

	mustEmbedBaseSimpleContractProcessor()
}

type BaseSimpleContractProcessor struct {
	Address  common.Address
	ABI      abi.ABI
	Contract *SimpleContract
	Eth      interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}
}

func (h *BaseSimpleContractProcessor) Setup(ctx context.Context, address common.Address, eth interface {
	ethereum.ChainReader
	ethereum.ChainStateReader
	ethereum.TransactionReader
	bind.ContractBackend
}) error {
	contract, err := NewSimpleContract(address, eth)
	if err != nil {
		return fmt.Errorf("new SimpleContract: %w", err)
	}

	abi, err := abi.JSON(strings.NewReader(string(SimpleContractABI)))
	if err != nil {
		return fmt.Errorf("parsing SimpleContract abi: %w", err)
	}

	h.Address = address
	h.ABI = abi
	h.Contract = contract
	h.Eth = eth
	return nil
}

func (h *BaseSimpleContractProcessor) ProcessElement(p interface{}) func(context.Context, types.Log) (func() error, error) {
	return func(ctx context.Context, vLog types.Log) (func() error, error) {
		switch vLog.Topics[0].Hex() {

		case h.ABI.Events["DataChanged"].ID.Hex():
			e := SimpleContractDataChanged{}
			if err := h.UnpackLog(&e, "DataChanged", vLog); err != nil {
				return nil, fmt.Errorf("unpacking DataChanged: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(SimpleContractProcessor).ProcessDataChanged(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing DataChanged: %w", err)
			}

			return cb, nil

		}
		return func() error { return nil }, nil
	}
}

func (h *BaseSimpleContractProcessor) UnpackLog(out interface{}, event string, log types.Log) error {
	if len(log.Data) > 0 {
		if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
			return err
		}
	}
	var indexed abi.Arguments
	for _, arg := range h.ABI.Events[event].Inputs {
		if arg.Indexed {
			indexed = append(indexed, arg)
		}
	}
	return abi.ParseTopics(out, indexed, log.Topics[1:])
}

func (h *BaseSimpleContractProcessor) Initialize(ctx context.Context, start uint64) error {
	return nil
}

func (h *BaseSimpleContractProcessor) ProcessDataChanged(ctx context.Context, e SimpleContractDataChanged) (func() error, error) {
	return func() error { return nil }, nil
}

func (h *BaseSimpleContractProcessor) mustEmbedBaseSimpleContractProcessor() {}
`,
		},
		{
			name:  "multiple_events_single_contract",
			types: []string{"MultiEvent"},
			abis: []string{`[
						{"name": "Event1", "type": "event", "inputs": [{"name": "a", "type": "uint256"}]},
						{"name": "Event2", "type": "event", "inputs": [{"name": "b", "type": "bool"}]}
					]`},
			pkg: "multipkg",
			expectedOutput: `// Code generated by github.com/withtally/synceth, DO NOT EDIT.

package multipkg

import (
	"context"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

type MultiEventProcessor interface {
	Setup(ctx context.Context, address common.Address, eth interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}) error
	Initialize(ctx context.Context, start uint64) error

	ProcessEvent1(ctx context.Context, e MultiEventEvent1) (func() error, error)

	ProcessEvent2(ctx context.Context, e MultiEventEvent2) (func() error, error)

	mustEmbedBaseMultiEventProcessor()
}

type BaseMultiEventProcessor struct {
	Address  common.Address
	ABI      abi.ABI
	Contract *MultiEvent
	Eth      interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}
}

func (h *BaseMultiEventProcessor) Setup(ctx context.Context, address common.Address, eth interface {
	ethereum.ChainReader
	ethereum.ChainStateReader
	ethereum.TransactionReader
	bind.ContractBackend
}) error {
	contract, err := NewMultiEvent(address, eth)
	if err != nil {
		return fmt.Errorf("new MultiEvent: %w", err)
	}

	abi, err := abi.JSON(strings.NewReader(string(MultiEventABI)))
	if err != nil {
		return fmt.Errorf("parsing MultiEvent abi: %w", err)
	}

	h.Address = address
	h.ABI = abi
	h.Contract = contract
	h.Eth = eth
	return nil
}

func (h *BaseMultiEventProcessor) ProcessElement(p interface{}) func(context.Context, types.Log) (func() error, error) {
	return func(ctx context.Context, vLog types.Log) (func() error, error) {
		switch vLog.Topics[0].Hex() {

		case h.ABI.Events["Event1"].ID.Hex():
			e := MultiEventEvent1{}
			if err := h.UnpackLog(&e, "Event1", vLog); err != nil {
				return nil, fmt.Errorf("unpacking Event1: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(MultiEventProcessor).ProcessEvent1(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing Event1: %w", err)
			}

			return cb, nil

		case h.ABI.Events["Event2"].ID.Hex():
			e := MultiEventEvent2{}
			if err := h.UnpackLog(&e, "Event2", vLog); err != nil {
				return nil, fmt.Errorf("unpacking Event2: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(MultiEventProcessor).ProcessEvent2(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing Event2: %w", err)
			}

			return cb, nil

		}
		return func() error { return nil }, nil
	}
}

func (h *BaseMultiEventProcessor) UnpackLog(out interface{}, event string, log types.Log) error {
	if len(log.Data) > 0 {
		if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
			return err
		}
	}
	var indexed abi.Arguments
	for _, arg := range h.ABI.Events[event].Inputs {
		if arg.Indexed {
			indexed = append(indexed, arg)
		}
	}
	return abi.ParseTopics(out, indexed, log.Topics[1:])
}

func (h *BaseMultiEventProcessor) Initialize(ctx context.Context, start uint64) error {
	return nil
}

func (h *BaseMultiEventProcessor) ProcessEvent1(ctx context.Context, e MultiEventEvent1) (func() error, error) {
	return func() error { return nil }, nil
}

func (h *BaseMultiEventProcessor) ProcessEvent2(ctx context.Context, e MultiEventEvent2) (func() error, error) {
	return func() error { return nil }, nil
}

func (h *BaseMultiEventProcessor) mustEmbedBaseMultiEventProcessor() {}
`,
		},
		{
			name:  "multiple_contracts",
			types: []string{"Contract1", "Contract2"},
			abis: []string{
				`[{"name": "Event1", "type": "event", "inputs": []}]`,
				`[{"name": "Event2", "type": "event", "inputs": []}]`,
			},
			pkg: "multipkg",
			expectedOutput: `// Code generated by github.com/withtally/synceth, DO NOT EDIT.

package multipkg

import (
	"context"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

type Contract1Processor interface {
	Setup(ctx context.Context, address common.Address, eth interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}) error
	Initialize(ctx context.Context, start uint64) error

	ProcessEvent1(ctx context.Context, e Contract1Event1) (func() error, error)

	mustEmbedBaseContract1Processor()
}

type BaseContract1Processor struct {
	Address  common.Address
	ABI      abi.ABI
	Contract *Contract1
	Eth      interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}
}

func (h *BaseContract1Processor) Setup(ctx context.Context, address common.Address, eth interface {
	ethereum.ChainReader
	ethereum.ChainStateReader
	ethereum.TransactionReader
	bind.ContractBackend
}) error {
	contract, err := NewContract1(address, eth)
	if err != nil {
		return fmt.Errorf("new Contract1: %w", err)
	}

	abi, err := abi.JSON(strings.NewReader(string(Contract1ABI)))
	if err != nil {
		return fmt.Errorf("parsing Contract1 abi: %w", err)
	}

	h.Address = address
	h.ABI = abi
	h.Contract = contract
	h.Eth = eth
	return nil
}

func (h *BaseContract1Processor) ProcessElement(p interface{}) func(context.Context, types.Log) (func() error, error) {
	return func(ctx context.Context, vLog types.Log) (func() error, error) {
		switch vLog.Topics[0].Hex() {

		case h.ABI.Events["Event1"].ID.Hex():
			e := Contract1Event1{}
			if err := h.UnpackLog(&e, "Event1", vLog); err != nil {
				return nil, fmt.Errorf("unpacking Event1: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(Contract1Processor).ProcessEvent1(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing Event1: %w", err)
			}

			return cb, nil

		}
		return func() error { return nil }, nil
	}
}

func (h *BaseContract1Processor) UnpackLog(out interface{}, event string, log types.Log) error {
	if len(log.Data) > 0 {
		if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
			return err
		}
	}
	var indexed abi.Arguments
	for _, arg := range h.ABI.Events[event].Inputs {
		if arg.Indexed {
			indexed = append(indexed, arg)
		}
	}
	return abi.ParseTopics(out, indexed, log.Topics[1:])
}

func (h *BaseContract1Processor) Initialize(ctx context.Context, start uint64) error {
	return nil
}

func (h *BaseContract1Processor) ProcessEvent1(ctx context.Context, e Contract1Event1) (func() error, error) {
	return func() error { return nil }, nil
}

func (h *BaseContract1Processor) mustEmbedBaseContract1Processor() {}

type Contract2Processor interface {
	Setup(ctx context.Context, address common.Address, eth interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}) error
	Initialize(ctx context.Context, start uint64) error

	ProcessEvent2(ctx context.Context, e Contract2Event2) (func() error, error)

	mustEmbedBaseContract2Processor()
}

type BaseContract2Processor struct {
	Address  common.Address
	ABI      abi.ABI
	Contract *Contract2
	Eth      interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}
}

func (h *BaseContract2Processor) Setup(ctx context.Context, address common.Address, eth interface {
	ethereum.ChainReader
	ethereum.ChainStateReader
	ethereum.TransactionReader
	bind.ContractBackend
}) error {
	contract, err := NewContract2(address, eth)
	if err != nil {
		return fmt.Errorf("new Contract2: %w", err)
	}

	abi, err := abi.JSON(strings.NewReader(string(Contract2ABI)))
	if err != nil {
		return fmt.Errorf("parsing Contract2 abi: %w", err)
	}

	h.Address = address
	h.ABI = abi
	h.Contract = contract
	h.Eth = eth
	return nil
}

func (h *BaseContract2Processor) ProcessElement(p interface{}) func(context.Context, types.Log) (func() error, error) {
	return func(ctx context.Context, vLog types.Log) (func() error, error) {
		switch vLog.Topics[0].Hex() {

		case h.ABI.Events["Event2"].ID.Hex():
			e := Contract2Event2{}
			if err := h.UnpackLog(&e, "Event2", vLog); err != nil {
				return nil, fmt.Errorf("unpacking Event2: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(Contract2Processor).ProcessEvent2(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing Event2: %w", err)
			}

			return cb, nil

		}
		return func() error { return nil }, nil
	}
}

func (h *BaseContract2Processor) UnpackLog(out interface{}, event string, log types.Log) error {
	if len(log.Data) > 0 {
		if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
			return err
		}
	}
	var indexed abi.Arguments
	for _, arg := range h.ABI.Events[event].Inputs {
		if arg.Indexed {
			indexed = append(indexed, arg)
		}
	}
	return abi.ParseTopics(out, indexed, log.Topics[1:])
}

func (h *BaseContract2Processor) Initialize(ctx context.Context, start uint64) error {
	return nil
}

func (h *BaseContract2Processor) ProcessEvent2(ctx context.Context, e Contract2Event2) (func() error, error) {
	return func() error { return nil }, nil
}

func (h *BaseContract2Processor) mustEmbedBaseContract2Processor() {}
`,
		},
		{
			name:  "event_with_arrays",
			types: []string{"ArrayContract"},
			abis: []string{`[{
						"name": "DataArray",
						"type": "event",
						"inputs": [
							{"name": "ids", "type": "uint256[]"},
							{"name": "addresses", "type": "address[]"}
						]
					}]`},
			pkg: "arraypkg",
			expectedOutput: `// Code generated by github.com/withtally/synceth, DO NOT EDIT.

package arraypkg

import (
	"context"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

type ArrayContractProcessor interface {
	Setup(ctx context.Context, address common.Address, eth interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}) error
	Initialize(ctx context.Context, start uint64) error

	ProcessDataArray(ctx context.Context, e ArrayContractDataArray) (func() error, error)

	mustEmbedBaseArrayContractProcessor()
}

type BaseArrayContractProcessor struct {
	Address  common.Address
	ABI      abi.ABI
	Contract *ArrayContract
	Eth      interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}
}

func (h *BaseArrayContractProcessor) Setup(ctx context.Context, address common.Address, eth interface {
	ethereum.ChainReader
	ethereum.ChainStateReader
	ethereum.TransactionReader
	bind.ContractBackend
}) error {
	contract, err := NewArrayContract(address, eth)
	if err != nil {
		return fmt.Errorf("new ArrayContract: %w", err)
	}

	abi, err := abi.JSON(strings.NewReader(string(ArrayContractABI)))
	if err != nil {
		return fmt.Errorf("parsing ArrayContract abi: %w", err)
	}

	h.Address = address
	h.ABI = abi
	h.Contract = contract
	h.Eth = eth
	return nil
}

func (h *BaseArrayContractProcessor) ProcessElement(p interface{}) func(context.Context, types.Log) (func() error, error) {
	return func(ctx context.Context, vLog types.Log) (func() error, error) {
		switch vLog.Topics[0].Hex() {

		case h.ABI.Events["DataArray"].ID.Hex():
			e := ArrayContractDataArray{}
			if err := h.UnpackLog(&e, "DataArray", vLog); err != nil {
				return nil, fmt.Errorf("unpacking DataArray: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(ArrayContractProcessor).ProcessDataArray(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing DataArray: %w", err)
			}

			return cb, nil

		}
		return func() error { return nil }, nil
	}
}

func (h *BaseArrayContractProcessor) UnpackLog(out interface{}, event string, log types.Log) error {
	if len(log.Data) > 0 {
		if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
			return err
		}
	}
	var indexed abi.Arguments
	for _, arg := range h.ABI.Events[event].Inputs {
		if arg.Indexed {
			indexed = append(indexed, arg)
		}
	}
	return abi.ParseTopics(out, indexed, log.Topics[1:])
}

func (h *BaseArrayContractProcessor) Initialize(ctx context.Context, start uint64) error {
	return nil
}

func (h *BaseArrayContractProcessor) ProcessDataArray(ctx context.Context, e ArrayContractDataArray) (func() error, error) {
	return func() error { return nil }, nil
}

func (h *BaseArrayContractProcessor) mustEmbedBaseArrayContractProcessor() {}
`,
		},
		{
			name:  "event_with_indexed_params",
			types: []string{"Transfer"},
			abis: []string{`[{
						"name": "Transfer",
						"type": "event",
						"inputs": [
							{"name": "from", "type": "address", "indexed": true},
							{"name": "to", "type": "address", "indexed": true},
							{"name": "value", "type": "uint256", "indexed": false}
						]
					}]`},
			pkg: "tokenpkg",
			expectedOutput: `// Code generated by github.com/withtally/synceth, DO NOT EDIT.

package tokenpkg

import (
	"context"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

type TransferProcessor interface {
	Setup(ctx context.Context, address common.Address, eth interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}) error
	Initialize(ctx context.Context, start uint64) error

	ProcessTransfer(ctx context.Context, e TransferTransfer) (func() error, error)

	mustEmbedBaseTransferProcessor()
}

type BaseTransferProcessor struct {
	Address  common.Address
	ABI      abi.ABI
	Contract *Transfer
	Eth      interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}
}

func (h *BaseTransferProcessor) Setup(ctx context.Context, address common.Address, eth interface {
	ethereum.ChainReader
	ethereum.ChainStateReader
	ethereum.TransactionReader
	bind.ContractBackend
}) error {
	contract, err := NewTransfer(address, eth)
	if err != nil {
		return fmt.Errorf("new Transfer: %w", err)
	}

	abi, err := abi.JSON(strings.NewReader(string(TransferABI)))
	if err != nil {
		return fmt.Errorf("parsing Transfer abi: %w", err)
	}

	h.Address = address
	h.ABI = abi
	h.Contract = contract
	h.Eth = eth
	return nil
}

func (h *BaseTransferProcessor) ProcessElement(p interface{}) func(context.Context, types.Log) (func() error, error) {
	return func(ctx context.Context, vLog types.Log) (func() error, error) {
		switch vLog.Topics[0].Hex() {

		case h.ABI.Events["Transfer"].ID.Hex():
			e := TransferTransfer{}
			if err := h.UnpackLog(&e, "Transfer", vLog); err != nil {
				return nil, fmt.Errorf("unpacking Transfer: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(TransferProcessor).ProcessTransfer(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing Transfer: %w", err)
			}

			return cb, nil

		}
		return func() error { return nil }, nil
	}
}

func (h *BaseTransferProcessor) UnpackLog(out interface{}, event string, log types.Log) error {
	if len(log.Data) > 0 {
		if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
			return err
		}
	}
	var indexed abi.Arguments
	for _, arg := range h.ABI.Events[event].Inputs {
		if arg.Indexed {
			indexed = append(indexed, arg)
		}
	}
	return abi.ParseTopics(out, indexed, log.Topics[1:])
}

func (h *BaseTransferProcessor) Initialize(ctx context.Context, start uint64) error {
	return nil
}

func (h *BaseTransferProcessor) ProcessTransfer(ctx context.Context, e TransferTransfer) (func() error, error) {
	return func() error { return nil }, nil
}

func (h *BaseTransferProcessor) mustEmbedBaseTransferProcessor() {}
`,
		},
		{
			name:  "empty_event",
			types: []string{"EmptyEvent"},
			abis: []string{`[{
						"name": "Started",
						"type": "event",
						"inputs": []
					}]`},
			pkg: "emptypkg",
			expectedOutput: `// Code generated by github.com/withtally/synceth, DO NOT EDIT.

package emptypkg

import (
	"context"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

type EmptyEventProcessor interface {
	Setup(ctx context.Context, address common.Address, eth interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}) error
	Initialize(ctx context.Context, start uint64) error

	ProcessStarted(ctx context.Context, e EmptyEventStarted) (func() error, error)

	mustEmbedBaseEmptyEventProcessor()
}

type BaseEmptyEventProcessor struct {
	Address  common.Address
	ABI      abi.ABI
	Contract *EmptyEvent
	Eth      interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}
}

func (h *BaseEmptyEventProcessor) Setup(ctx context.Context, address common.Address, eth interface {
	ethereum.ChainReader
	ethereum.ChainStateReader
	ethereum.TransactionReader
	bind.ContractBackend
}) error {
	contract, err := NewEmptyEvent(address, eth)
	if err != nil {
		return fmt.Errorf("new EmptyEvent: %w", err)
	}

	abi, err := abi.JSON(strings.NewReader(string(EmptyEventABI)))
	if err != nil {
		return fmt.Errorf("parsing EmptyEvent abi: %w", err)
	}

	h.Address = address
	h.ABI = abi
	h.Contract = contract
	h.Eth = eth
	return nil
}

func (h *BaseEmptyEventProcessor) ProcessElement(p interface{}) func(context.Context, types.Log) (func() error, error) {
	return func(ctx context.Context, vLog types.Log) (func() error, error) {
		switch vLog.Topics[0].Hex() {

		case h.ABI.Events["Started"].ID.Hex():
			e := EmptyEventStarted{}
			if err := h.UnpackLog(&e, "Started", vLog); err != nil {
				return nil, fmt.Errorf("unpacking Started: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(EmptyEventProcessor).ProcessStarted(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing Started: %w", err)
			}

			return cb, nil

		}
		return func() error { return nil }, nil
	}
}

func (h *BaseEmptyEventProcessor) UnpackLog(out interface{}, event string, log types.Log) error {
	if len(log.Data) > 0 {
		if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
			return err
		}
	}
	var indexed abi.Arguments
	for _, arg := range h.ABI.Events[event].Inputs {
		if arg.Indexed {
			indexed = append(indexed, arg)
		}
	}
	return abi.ParseTopics(out, indexed, log.Topics[1:])
}

func (h *BaseEmptyEventProcessor) Initialize(ctx context.Context, start uint64) error {
	return nil
}

func (h *BaseEmptyEventProcessor) ProcessStarted(ctx context.Context, e EmptyEventStarted) (func() error, error) {
	return func() error { return nil }, nil
}

func (h *BaseEmptyEventProcessor) mustEmbedBaseEmptyEventProcessor() {}
`,
		},
		{
			name:  "complex_event_signature",
			types: []string{"Complex"},
			abis: []string{`[{
						"name": "ComplexData",
						"type": "event",
						"inputs": [
							{"name": "id", "type": "bytes32"},
							{"name": "amounts", "type": "uint256[]"},
							{"name": "active", "type": "bool"},
							{"name": "data", "type": "bytes"}
						]
					}]`},
			pkg: "complexpkg",
			expectedOutput: `// Code generated by github.com/withtally/synceth, DO NOT EDIT.

package complexpkg

import (
	"context"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

type ComplexProcessor interface {
	Setup(ctx context.Context, address common.Address, eth interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}) error
	Initialize(ctx context.Context, start uint64) error

	ProcessComplexData(ctx context.Context, e ComplexComplexData) (func() error, error)

	mustEmbedBaseComplexProcessor()
}

type BaseComplexProcessor struct {
	Address  common.Address
	ABI      abi.ABI
	Contract *Complex
	Eth      interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}
}

func (h *BaseComplexProcessor) Setup(ctx context.Context, address common.Address, eth interface {
	ethereum.ChainReader
	ethereum.ChainStateReader
	ethereum.TransactionReader
	bind.ContractBackend
}) error {
	contract, err := NewComplex(address, eth)
	if err != nil {
		return fmt.Errorf("new Complex: %w", err)
	}

	abi, err := abi.JSON(strings.NewReader(string(ComplexABI)))
	if err != nil {
		return fmt.Errorf("parsing Complex abi: %w", err)
	}

	h.Address = address
	h.ABI = abi
	h.Contract = contract
	h.Eth = eth
	return nil
}

func (h *BaseComplexProcessor) ProcessElement(p interface{}) func(context.Context, types.Log) (func() error, error) {
	return func(ctx context.Context, vLog types.Log) (func() error, error) {
		switch vLog.Topics[0].Hex() {

		case h.ABI.Events["ComplexData"].ID.Hex():
			e := ComplexComplexData{}
			if err := h.UnpackLog(&e, "ComplexData", vLog); err != nil {
				return nil, fmt.Errorf("unpacking ComplexData: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(ComplexProcessor).ProcessComplexData(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing ComplexData: %w", err)
			}

			return cb, nil

		}
		return func() error { return nil }, nil
	}
}

func (h *BaseComplexProcessor) UnpackLog(out interface{}, event string, log types.Log) error {
	if len(log.Data) > 0 {
		if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
			return err
		}
	}
	var indexed abi.Arguments
	for _, arg := range h.ABI.Events[event].Inputs {
		if arg.Indexed {
			indexed = append(indexed, arg)
		}
	}
	return abi.ParseTopics(out, indexed, log.Topics[1:])
}

func (h *BaseComplexProcessor) Initialize(ctx context.Context, start uint64) error {
	return nil
}

func (h *BaseComplexProcessor) ProcessComplexData(ctx context.Context, e ComplexComplexData) (func() error, error) {
	return func() error { return nil }, nil
}

func (h *BaseComplexProcessor) mustEmbedBaseComplexProcessor() {}
`,
		},
		{
			name:  "anonymous_event_skipped",
			types: []string{"AnonOnly"},
			abis: []string{`[{
						"name": "Anonymous",
						"type": "event",
						"anonymous": true,
						"inputs": [{"name": "data", "type": "bytes32"}]
					}]`},
			pkg:         "anonpkg",
			wantErr:     true,
			errContains: "no events",
		},
		{
			name:        "invalid_abi_json",
			types:       []string{"Invalid"},
			abis:        []string{`invalid json`},
			pkg:         "invalidpkg",
			wantErr:     true,
			errContains: "parsing abi",
		},
		{
			name:        "no_events_in_contract",
			types:       []string{"NoEvents"},
			abis:        []string{`[]`},
			pkg:         "noeventspkg",
			wantErr:     true,
			errContains: "no events",
		},
		{
			name:  "event_name_normalization",
			types: []string{"NormTest"},
			abis: []string{`[{
						"name": "user_data_updated",
						"type": "event",
						"inputs": [{"name": "user_id", "type": "uint256"}]
					}]`},
			pkg: "normpkg",
			expectedOutput: `// Code generated by github.com/withtally/synceth, DO NOT EDIT.

package normpkg

import (
	"context"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

type NormTestProcessor interface {
	Setup(ctx context.Context, address common.Address, eth interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}) error
	Initialize(ctx context.Context, start uint64) error

	ProcessUserDataUpdated(ctx context.Context, e NormTestUserDataUpdated) (func() error, error)

	mustEmbedBaseNormTestProcessor()
}

type BaseNormTestProcessor struct {
	Address  common.Address
	ABI      abi.ABI
	Contract *NormTest
	Eth      interface {
		ethereum.ChainReader
		ethereum.ChainStateReader
		ethereum.TransactionReader
		bind.ContractBackend
	}
}

func (h *BaseNormTestProcessor) Setup(ctx context.Context, address common.Address, eth interface {
	ethereum.ChainReader
	ethereum.ChainStateReader
	ethereum.TransactionReader
	bind.ContractBackend
}) error {
	contract, err := NewNormTest(address, eth)
	if err != nil {
		return fmt.Errorf("new NormTest: %w", err)
	}

	abi, err := abi.JSON(strings.NewReader(string(NormTestABI)))
	if err != nil {
		return fmt.Errorf("parsing NormTest abi: %w", err)
	}

	h.Address = address
	h.ABI = abi
	h.Contract = contract
	h.Eth = eth
	return nil
}

func (h *BaseNormTestProcessor) ProcessElement(p interface{}) func(context.Context, types.Log) (func() error, error) {
	return func(ctx context.Context, vLog types.Log) (func() error, error) {
		switch vLog.Topics[0].Hex() {

		case h.ABI.Events["UserDataUpdated"].ID.Hex():
			e := NormTestUserDataUpdated{}
			if err := h.UnpackLog(&e, "UserDataUpdated", vLog); err != nil {
				return nil, fmt.Errorf("unpacking UserDataUpdated: %w", err)
			}

			e.Raw = vLog
			cb, err := p.(NormTestProcessor).ProcessUserDataUpdated(ctx, e)
			if err != nil {
				return nil, fmt.Errorf("processing UserDataUpdated: %w", err)
			}

			return cb, nil

		}
		return func() error { return nil }, nil
	}
}

func (h *BaseNormTestProcessor) UnpackLog(out interface{}, event string, log types.Log) error {
	if len(log.Data) > 0 {
		if err := h.ABI.UnpackIntoInterface(out, event, log.Data); err != nil {
			return err
		}
	}
	var indexed abi.Arguments
	for _, arg := range h.ABI.Events[event].Inputs {
		if arg.Indexed {
			indexed = append(indexed, arg)
		}
	}
	return abi.ParseTopics(out, indexed, log.Topics[1:])
}

func (h *BaseNormTestProcessor) Initialize(ctx context.Context, start uint64) error {
	return nil
}

func (h *BaseNormTestProcessor) ProcessUserDataUpdated(ctx context.Context, e NormTestUserDataUpdated) (func() error, error) {
	return func() error { return nil }, nil
}

func (h *BaseNormTestProcessor) mustEmbedBaseNormTestProcessor() {}
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			output, err := GenerateProcessor(tt.types, tt.abis, tt.pkg, tt.inputs, tt.setupInputs)
			if tt.wantErr {
				require.Error(t, err)
				if tt.errContains != "" {
					assert.Contains(t, err.Error(), tt.errContains)
				}
			} else {
				require.NoError(t, err)
				assert.Equal(t, tt.expectedOutput, output, "Output mismatch for test case: %s", tt.name)
			}
		})
	}
}

// TestProcessorHelperFunctions tests the utility functions used in processor generation.
// These helper functions handle:
// 1. generateAlias() - Creates aliases for input parameters
// 2. formatPointer() - Formats pointer types correctly for Go code
// 3. indirect() - Resolves pointer indirection for reflection types
func TestProcessorHelperFunctions(t *testing.T) {
	t.Run("generateAlias", func(t *testing.T) {
		// Test with alias
		alias := "myAlias"
		result := generateAlias(&alias)
		assert.Equal(t, "myAlias ", result)

		// Test without alias
		result = generateAlias(nil)
		assert.Equal(t, "", result)
	})

	t.Run("formatPointer", func(t *testing.T) {
		// Test pointer type
		result := formatPointer(reflect.Ptr)
		assert.Equal(t, "*", result)

		// Test non-pointer type
		result = formatPointer(reflect.String)
		assert.Equal(t, "", result)
	})

	t.Run("indirect", func(t *testing.T) {
		// Test with pointer type
		strType := reflect.TypeOf("")
		ptrType := reflect.PtrTo(strType)
		result := indirect(ptrType)
		assert.Equal(t, strType, result)

		// Test with non-pointer type
		result = indirect(strType)
		assert.Equal(t, strType, result)
	})
}
