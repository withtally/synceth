package codegen

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestGenerateFake comprehensively tests the GenerateFake function with various scenarios.
// This consolidated test covers:
// - Basic function generation with view/pure functions
// - Event generation with fakeEmit functions
// - Error handling for invalid ABIs
// - Custom Solidity version support
// - Functions with multiple outputs
// - Functions with inputs (parameters ignored in fake)
// - Events with indexed parameters
// - Memory keyword handling for reference types
// - Anonymous events
// - Struct definitions in events
// - Functions with no outputs
// - Edge cases where functions with structs are skipped
// - Empty ABI generation
// - Complex nested struct scenarios
func TestGenerateFake(t *testing.T) {
	tests := []struct {
		name           string
		typ            string
		abi            string
		version        *string
		expectedOutput string
		wantErr        bool
		errContains    string
	}{
		{
			name: "basic_view_function",
			typ:  "SimpleView",
			abi: `[{
				"name": "getValue",
				"type": "function",
				"stateMutability": "view",
				"inputs": [],
				"outputs": [{"name": "", "type": "uint256"}]
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeSimpleView {
	

	
		
			
			
			
				uint256 private _retuint256GetValue0;

				function fakeSetGetValue(uint256 retuint256GetValue0) public {
				_retuint256GetValue0 = retuint256GetValue0;

				}
			

			function getValue() public view returns (uint256) {
				return (
					
					
						_retuint256GetValue0
					
				);
			}
		
	
}
`,
		},
		{
			name: "event_generation",
			typ:  "EventContract",
			abi: `[{
				"name": "DataStored",
				"type": "event",
				"inputs": [{"name": "data", "type": "bytes32"}]
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeEventContract {
	
		
			
		

		event DataStored(bytes32 data);
		function fakeEmitDataStored(bytes32 data) public {
			emit DataStored(data);
		}
	

	
}
`,
		},
		{
			name:        "invalid_abi",
			typ:         "Invalid",
			abi:         `invalid json`,
			wantErr:     true,
			errContains: "parsing abi",
		},
		{
			name:    "custom_solidity_version",
			typ:     "Custom",
			abi:     `[]`,
			version: stringPtr("0.8.19"),
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity 0.8.19;

contract FakeCustom {
	

	
}
`,
		},
		{
			name: "function_with_multiple_outputs",
			typ:  "MultiOutput",
			abi: `[{
				"name": "getValues",
				"type": "function",
				"stateMutability": "view",
				"inputs": [],
				"outputs": [
					{"name": "a", "type": "uint256"},
					{"name": "b", "type": "bool"}
				]
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeMultiOutput {
	

	
		
			
			
			
				uint256 private _uint256GetValuesa;
bool private _boolGetValuesb;

				function fakeSetGetValues(uint256 uint256GetValuesa, bool boolGetValuesb) public {
				_uint256GetValuesa = uint256GetValuesa;
_boolGetValuesb = boolGetValuesb;

				}
			

			function getValues() public view returns (uint256, bool) {
				return (
					
					
						_uint256GetValuesa
					
						, _boolGetValuesb
					
				);
			}
		
	
}
`,
		},
		{
			name: "function_with_inputs",
			typ:  "WithInputs",
			abi: `[{
				"name": "calculate",
				"type": "function",
				"stateMutability": "pure",
				"inputs": [
					{"name": "x", "type": "uint256"},
					{"name": "y", "type": "uint256"}
				],
				"outputs": [{"name": "result", "type": "uint256"}]
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeWithInputs {
	

	
		
			
			
			
				uint256 private _uint256Calculateresult;

				function fakeSetCalculate(uint256 uint256Calculateresult) public {
				_uint256Calculateresult = uint256Calculateresult;

				}
			

			function calculate(x uint256, y uint256) public view returns (uint256) {
				return (
					
					
						_uint256Calculateresult
					
				);
			}
		
	
}
`,
		},
		{
			name: "event_with_indexed_params",
			typ:  "IndexedEvent",
			abi: `[{
				"name": "Transfer",
				"type": "event",
				"inputs": [
					{"name": "from", "type": "address", "indexed": true},
					{"name": "to", "type": "address", "indexed": true},
					{"name": "value", "type": "uint256", "indexed": false}
				]
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeIndexedEvent {
	
		
			
		
			
		
			
		

		event Transfer(address indexed from, address indexed to, uint256 value);
		function fakeEmitTransfer(address from, address to, uint256 value) public {
			emit Transfer(from, to, value);
		}
	

	
}
`,
		},
		{
			name: "function_with_memory_params",
			typ:  "MemoryParams",
			abi: `[{
				"name": "setData",
				"type": "function",
				"stateMutability": "nonpayable",
				"inputs": [
					{"name": "data", "type": "string"},
					{"name": "values", "type": "uint256[]"}
				],
				"outputs": []
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeMemoryParams {
	

	
		
			
			
			

			function setData(string memory, uint256[] memory) public view {
				
			}
		
	
}
`,
		},
		{
			name: "anonymous_event",
			typ:  "AnonEvent",
			abi: `[{
				"name": "Anonymous",
				"type": "event",
				"anonymous": true,
				"inputs": [{"name": "data", "type": "bytes32"}]
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeAnonEvent {
	
		
			
		

		event Anonymous(bytes32 data);
		function fakeEmitAnonymous(bytes32 data) public {
			emit Anonymous(data);
		}
	

	
}
`,
		},
		{
			name: "struct_in_event",
			typ:  "StructCheck",
			abi: `[{
				"name": "StructEvent",
				"type": "event",
				"inputs": [{
					"name": "data",
					"type": "tuple",
					"components": [
						{"name": "id", "type": "uint256"},
						{"name": "value", "type": "string"}
					]
				}]
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeStructCheck {
	
		
			
				struct Data {
uint256 id;
string value;
}
			
		

		event StructEvent(Data data);
		function fakeEmitStructEvent(Data memory data) public {
			emit StructEvent(data);
		}
	

	
}
`,
		},
		{
			name: "function_no_outputs",
			typ:  "NoOutputs",
			abi: `[{
				"name": "doSomething",
				"type": "function",
				"stateMutability": "nonpayable",
				"inputs": [],
				"outputs": []
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeNoOutputs {
	

	
		
			
			
			

			function doSomething() public view {
				
			}
		
	
}
`,
		},
		{
			name: "function_with_struct_output_skipped",
			typ:  "HasStruct",
			abi: `[{
				"name": "getValue",
				"type": "function",
				"stateMutability": "view",
				"inputs": [],
				"outputs": [{
					"name": "data",
					"type": "tuple",
					"components": [
						{"name": "id", "type": "uint256"},
						{"name": "name", "type": "string"}
					]
				}]
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeHasStruct {
	

	
		
	
}
`,
		},
		{
			name: "function_with_struct_input_skipped",
			typ:  "StructInput",
			abi: `[{
				"name": "process",
				"type": "function",
				"stateMutability": "nonpayable",
				"inputs": [{
					"name": "data",
					"type": "tuple",
					"components": [
						{"name": "value", "type": "uint256"}
					]
				}],
				"outputs": []
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeStructInput {
	

	
		
	
}
`,
		},
		{
			name: "empty_abi",
			typ:  "Valid",
			abi:  `[]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeValid {
	

	
}
`,
		},
		{
			name: "complex_nested_structs",
			typ:  "StructDef",
			abi: `[{
				"name": "ComplexEvent",
				"type": "event",
				"inputs": [{
					"name": "data",
					"type": "tuple",
					"components": [
						{"name": "id", "type": "uint256"},
						{
							"name": "nested",
							"type": "tuple",
							"components": [
								{"name": "value", "type": "string"}
							]
						}
					]
				}]
			}]`,
			expectedOutput: `
// Code generated by github.com/withtally/synceth, DO NOT EDIT.

pragma solidity ^0.8.3;

contract FakeStructDef {
	
		
			
				struct Data {
uint256 id;
string nested;
}
			
		

		event ComplexEvent(Data data);
		function fakeEmitComplexEvent(Data memory data) public {
			emit ComplexEvent(data);
		}
	

	
}
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			output, err := GenerateFake(tt.typ, tt.abi, tt.version)
			if tt.wantErr {
				require.Error(t, err)
				if tt.errContains != "" {
					assert.Contains(t, err.Error(), tt.errContains)
				}
			} else {
				require.NoError(t, err)
				assert.Equal(t, tt.expectedOutput, output, "Output mismatch for test case: %s", tt.name)
			}
		})
	}
}

// TestFakeHelperFunctions tests the utility functions used in fake generation.
// These helper functions handle string manipulation and type detection:
// 1. separator() - Generates comma separators for function parameters
// 2. location() - Determines memory/storage/calldata location for types
// 3. output() - Generates variable names for return values
// Testing these ensures consistent code generation.
func TestFakeHelperFunctions(t *testing.T) {
	t.Run("separator", func(t *testing.T) {
		// Test separator() which creates a closure that returns empty string on first call,
		// then the separator string on subsequent calls (for comma-separated lists)
		sep := separator("")
		assert.Equal(t, "", sep()) // First call: empty
		assert.Equal(t, "", sep()) // Second call: empty (separator is "")

		sep2 := separator(", ")
		assert.Equal(t, "", sep2())   // First call: empty
		assert.Equal(t, ", ", sep2()) // Second call: returns separator
	})

	t.Run("location", func(t *testing.T) {
		// Test location() function which adds 'memory' keyword for reference types
		assert.Equal(t, "uint256", location("uint256")) // Value types: no memory keyword
		assert.Equal(t, "bool", location("bool"))
		assert.Equal(t, "address", location("address"))
		assert.Equal(t, "string memory", location("string")) // Reference types: add memory
		assert.Equal(t, "bytes memory", location("bytes"))
		assert.Equal(t, "uint256[] memory", location("uint256[]")) // Arrays: add memory
		assert.Equal(t, "SomeStruct", location("SomeStruct"))      // Structs: no memory (handled elsewhere)
	})

	t.Run("output_function", func(t *testing.T) {
		// Test with empty name
		result := output("MyFunc", "uint256", "", 0)
		assert.Equal(t, "retuint256MyFunc0", result)

		// Test with name
		result = output("MyFunc", "uint256", "value", 0)
		assert.Equal(t, "uint256MyFuncvalue", result)

		// Test with array type
		result = output("MyFunc", "uint256[]", "values", 1)
		assert.Equal(t, "uint256ArrayMyFuncvalues", result)
	})
}

// Helper function for string pointers
func stringPtr(s string) *string {
	return &s
}
